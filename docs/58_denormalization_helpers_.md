# Chapter 58: Denormalization Helpers

Welcome back! In the previous chapters, we explored various planning modules like Assortment Plan Output ([Chapter 35](35_assortment_plan_output__apoutputgroupmodule__.md)), OTB Calculation ([Chapter 36](36_otb_calculation__otbgroupmodule__.md)), and Distribution ([Chapter 46](46_distribution_module_.md)). These modules perform complex calculations and produce crucial outputs, such as the final number of styles to carry (`options`) or the quantity to buy (`stocks` or `reorderQty`).

However, if you look closely at the direct output rows from these modules (like `ApOutputRow`, `OtbStyleBuyRow`, `DistOutputRow`), you'll often find they contain a lot of *IDs* – numbers representing stores, attribute groups, styles, or SKUs. For example, an `ApOutputRow` might tell you: `store=101, ag=500, options=5, stocks=300`.

## What Problem Do Denormalization Helpers Solve?

Imagine getting a report like that: `store=101, ag=500, options=5, stocks=300`. While accurate for the system, it's not very helpful for a human user or another system that needs more context! You'd immediately ask:
*   "What *is* Store 101? Is that the downtown branch or the mall location?"
*   "What products are in Attribute Group 500? Is that Men's T-shirts or Women's Dresses? What brand? What price bucket?"

To understand the plan, you'd need separate lookup tables or master files to translate `101` into "Downtown Branch" and `500` into "Men's, BrandX, Premium, V-Neck T-Shirts". Doing this manually for potentially thousands of rows in the output file is incredibly tedious and inefficient.

**Denormalization Helpers** solve this problem. They act like automatic **report enrichers** or **translators**. They take the raw, often ID-heavy output generated by the core algorithm modules and automatically "look up" the descriptive information associated with those IDs, combining everything into a single, wide, easy-to-understand output format.

## Core Idea: Combining IDs with Names and Descriptions

Think of the raw module output as a coded message: `ID101 needs 5 of ID500`. The Denormalization Helper is the decoder ring and dictionary. It takes the coded message and turns it into a readable sentence: `"Downtown Branch" needs 5 options of "Men's BrandX Premium V-Neck T-Shirts"`.

How do they do this?

1.  **Get Raw Output:** They start with the list of output rows containing IDs (e.g., `List<ApOutputRow>`).
2.  **Access Master Data:** They use the central [Cache](05_cache_.md), which holds all the "dictionary" information – maps linking store IDs to `StoreRow` objects (containing names, channels, regions), AG IDs to `AgRow` objects (containing category, brand, attributes), Style IDs to `StyleRow` objects, etc.
3.  **Lookup and Join:** For *each* raw output row, the helper looks up the corresponding master data objects in the Cache using the IDs.
4.  **Create Enriched Row:** It then creates a *new* type of output row (often called `Denorm...Row` or `Export...Row`) that includes both the original calculated values (like `options`, `stocks`) AND the descriptive fields pulled from the master data (like `storeName`, `channel`, `category`, `brand`, `priceBucket`, etc.).
5.  **Produce Rich Output:** The final result is a list of these enriched rows, perfect for user reports, BI tools, or downstream systems that need descriptive context.

These helpers "denormalize" the data – moving from efficient, ID-based storage back to a wider, more redundant but human-readable format.

## How It Works (The Workflow)

Denormalization Helpers aren't complex modules themselves. They are typically **utility classes** (`@Component` beans in Spring) that are *called* by the final output module within a larger group (like `ApOutputModule`, `OtbOutputModule`, `DistributionOutputModule`).

**The Process:**

1.  A main calculation module finishes (e.g., `OdApOutputModule` calculates the `ApOutputRow` list).
2.  The coordinating output module (e.g., `OdApOutputModule` or a dedicated `ApOutputModule`) takes the primary output list (e.g., `List<ApOutputRow>`).
3.  It injects (`@Autowired`) the relevant Denormalization Helper (e.g., `DenormalizedApOutputsHelper`).
4.  It calls a method on the helper, passing the primary output list (e.g., `denormalizedApHelper.getExportApOutputRows(apOutputRowList)`).
5.  The helper performs the lookup-and-join process described above, using the Cache.
6.  The helper returns a new list of enriched rows (e.g., `List<ExportApOutputRow>`).
7.  The output module then saves this enriched list to a file or database table.

**Inputs (for the Helper):**
*   The list of primary, ID-based output rows (e.g., `List<ApOutputRow>`).
*   Access to the [Cache](05_cache_.md) (usually via `@Autowired`).

**Outputs (from the Helper):**
*   A list of denormalized, enriched output rows (e.g., `List<ExportApOutputRow>`, `List<DenormDistParentAllocRow>`).

## Under the Hood: Looping and Looking Up

These helper classes contain straightforward logic: iterate through the input list, perform lookups for each row, and build the output list.

**1. Conceptual Sequence:**

```mermaid
sequenceDiagram
    participant OutputMod as Output Module (e.g., OdApOutputModule)
    participant Helper as Denorm Helper (e.g., DenormalizedApOutputsHelper)
    participant InputList as List<ApOutputRow>
    participant Cache as Cache
    participant OutputList as List<ExportApOutputRow>

    OutputMod ->> Helper: getExportApOutputRows(inputList)
    Helper ->> OutputList: Create empty list
    loop For each inputRow in InputList
        Helper ->> Cache: getStoreRow(inputRow.store)
        Cache -->> Helper: Return storeDetails (StoreRow)
        Helper ->> Cache: getAgRow(inputRow.ag)
        Cache -->> Helper: Return agDetails (AgRow)
        Helper ->> Helper: Create new ExportApOutputRow (exportRow)
        Helper ->> Helper: Copy inputRow.options to exportRow.apOptions
        Helper ->> Helper: Copy inputRow.stocks to exportRow.apStocks
        Helper ->> Helper: Copy storeDetails.name to exportRow.store
        Helper ->> Helper: Copy storeDetails.channel to exportRow.channel
        Helper ->> Helper: Copy agDetails.cat to exportRow.category
        Helper ->> Helper: Copy agDetails.brand to exportRow.brand
        Helper ->> Helper: Copy agDetails.theme to exportRow.theme
         // ... copy many other fields ...
        Helper ->> OutputList: Add populated exportRow
    end
    Helper -->> OutputMod: Return OutputList (enriched rows)
    OutputMod ->> OutputMod: Persist OutputList
```
**Explanation:** The sequence shows the Output Module calling the Helper. The Helper iterates through the input list (`InputList`). For each row, it makes calls to the Cache to fetch related `StoreRow` and `AgRow` data based on IDs. It then creates a new, wider `ExportApOutputRow` and populates it with data from *both* the original input row and the retrieved master data objects before adding it to the final `OutputList`.

**2. Code Dive:**
Let's look at simplified examples from the helper classes provided in the context.

*   **`DenormalizedApOutputsHelper.getExportApOutputRow`:** (Used by AP Output)
    ```java
    // Simplified from DenormalizedApOutputsHelper.java

    @Autowired private Cache cache;
    // Input: segmentationRow has store, ag; apOutputRow has options, stocks
    private ExportApOutputRow getExportApOutputRow(OdSegmentationRow odSegmentationRow, ApOutputRow apOutputRow) {
        ExportApOutputRow r = new ExportApOutputRow(); // Create the enriched output row object

        // --- Lookup Master Data using IDs ---
        StoreRow storeRow = cache.getStoreRow(odSegmentationRow.store);
        AgRow agRow = cache.getAgRow(odSegmentationRow.ag);

        // --- Populate descriptive fields from master data ---
        r.channel = storeRow.channel;
        r.region = storeRow.region;
        r.store = storeRow.store; // Store name
        r.storeCode = storeRow.storeCode;
        // ... (populate class, cluster) ...
        r.ag = agRow.ag; // AG key string
        r.category = agRow.cat;
        r.masterCategory = cache.getMasterCatFromCat(agRow.cat); // Another lookup
        r.subcategory = agRow.subcat;
        r.brand = agRow.brand;
        r.gender = agRow.gender;
        r.brandSegment = agRow.brandSegment;
        r.priceBucket = agRow.priceBucket;
        r.theme = agRow.theme;
        r.attribute1 = agRow.a1;
        r.attribute2 = agRow.a2;
        // ... (populate attributes 3-10) ...

        // --- Populate calculated values from primary output ---
        r.period = odSegmentationRow.period;
        r.revContri = odSegmentationRow.finalStoreRevContri; // From OD
        r.apStocks = apOutputRow.stocks; // From AP Output
        r.apOptions = apOutputRow.options; // From AP Output

        // ... (Logic to get sizeSets and sizeRatio - involves other lookups) ...
        r.sizeSets = /* ... get size info ... */;
        r.sizeRatio = /* ... get ratio info ... */;

        return r; // Return the populated enriched row
    }
    ```
    **Explanation:** This method takes the ID-based rows (`OdSegmentationRow` for context, `ApOutputRow` for results) as input. It uses the IDs (`odSegmentationRow.store`, `odSegmentationRow.ag`) to fetch the full `StoreRow` and `AgRow` from the `cache`. It then populates the `ExportApOutputRow` (`r`) with descriptive fields from `storeRow` and `agRow` (like `channel`, `region`, `category`, `brand`, attributes) as well as the calculated values from the input rows (`apStocks`, `apOptions`, `revContri`).

*   **`DenormalizedDistOutputsHelper.getExportDistAllocRow`:** (Used by Distribution Output)
    ```java
    // Simplified from DenormalizedDistOutputsHelper.java

    @Autowired private Cache cache;
    // Input: distOutputRow has store, sku, style, allocWh, allocTtl, ros, etc.
    private <T extends ExportDistAllocRow> T getExportDistAllocRow(DistOutputRow distOutputRow, Class<T> clazz) {
        T r = getNewInstance(clazz); // Create the enriched output row object

        // --- Lookup Master Data using IDs ---
        StoreRow storeRow = storeRowMap.get(distOutputRow.store); // Assumes storeRowMap is pre-populated
        SkuRow skuRow = skuRowMap.get(distOutputRow.sku);       // Assumes skuRowMap is pre-populated
        StyleRow styleRow = styleRowMap.get(distOutputRow.style);   // Assumes styleRowMap is pre-populated

        // --- Populate descriptive fields from master data ---
        r.store = storeRow.store;
        r.storeCode = storeRow.storeCode;
        r.channel = storeRow.channel;
        // ... (populate class, cluster, city, region) ...
        r.ean = skuRow.ean;
        r.styleCode = styleRow.styleCode;
        r.description = styleRow.description;
        r.category = styleRow.cat;
        r.subcategory = styleRow.subcat;
        r.masterCategory = styleRow.masterCat;
        r.gender = styleRow.gender;
        r.brand = styleRow.brand;
        // ... (populate brandSegment, season, styleTag) ...
        r.size = skuRow.size;
        r.sizeGroup = distOutputRow.sizeGroup; // Copy from input
        r.parentStyle = cache.getStyleRow(cache.getStyleParent(distOutputRow.style)).styleCode; // Lookup parent

        // --- Populate calculated values from primary output ---
        r.allocWh = distOutputRow.allocWh; // Warehouse allocation
        r.allocTtl = distOutputRow.allocTtl; // Total allocation
        r.final_ros = distOutputRow.ros; // Calculated ROS
        r.outwards = distOutputRow.outwards; // Outward quantity (from IST maybe)
        r.allocationType = distOutputRow.allocationType; // Type of allocation
        r.iterationFlag = distOutputRow.iterationFlag; // Which iteration made decision
        r.segment = (distOutputRow.segment != null) ? distOutputRow.segment.toString() : EMPTY_STRING; // Performance segment

        // ... (populate GIT, IIT, Open Orders, stock breakdown using other maps) ...
        r.remarks = distOutputRow.remarks;

        return r; // Return the populated enriched row
    }
    ```
    **Explanation:** Similar to the previous example, this method takes the ID-based `DistOutputRow`. It uses pre-populated maps (`storeRowMap`, `skuRowMap`, `styleRowMap`) or the `cache` to get the full `StoreRow`, `SkuRow`, and `StyleRow`. It populates the `ExportDistAllocRow` (`r`) with descriptive fields from these master objects alongside the calculated allocation quantities, ROS, segment, and other metrics from the input `distOutputRow`.

## Conclusion

**Denormalization Helpers** are essential utility classes in `irisx-algo` that bridge the gap between efficient, ID-based internal data and user-friendly, descriptive outputs.

*   They take the **ID-heavy results** from core algorithm modules (like AP Output, OTB, Distribution).
*   They use the central **[Cache](05_cache_.md)** to look up associated **master data** (names, descriptions, categories, brands, etc.).
*   They **combine** the calculated results with the descriptive master data into **wide, denormalized output rows** (often named `Export...Row` or `Denorm...Row`).
*   This makes the final outputs much **easier for users to read, analyze, report on, and integrate** with other systems.

These helpers are the final step in polishing the output of complex calculations into a consumable format, ensuring the insights generated by `irisx-algo` are easily accessible and understandable.

With all this detailed planning and output generation, how can businesses easily analyze trends and performance across different dimensions using standard reporting tools? The next chapter explores a module designed specifically for that.

[Next Chapter: BI Data Preparation Module](59_bi_data_preparation_module_.md)
```

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)