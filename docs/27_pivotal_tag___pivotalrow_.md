# Chapter 27: Pivotal Tag / PivotalRow

Welcome back! In the [previous chapter](26_ideal_size_set__iss__module__apissgroupmodule__.md), we explored the [Ideal Size Set (ISS) Module (ApIssGroupModule)](26_ideal_size_set__iss__module__apissgroupmodule__.md), which helps determine the best *range* of sizes to offer for a product group in a specific store. It figures out which sizes are crucial based on sales data and continuity rules.

But just knowing the *set* of sizes isn't enough. Within that set, some sizes are clearly more important than others. How do we specifically label each size to reflect its importance and use that label to make decisions?

## What Problem Do Pivotal Tag / PivotalRow Solve?

Let's revisit our V-Neck T-shirt example in Store 101. The ISS module might have recommended stocking sizes S, M, L, and XL (maybe XXL was deemed an 'Exit' size). However, we know from the analysis that M and L are the top sellers, XL sells okay, and S sells the least among these four.

When planning how many units of each size to buy or send to the store, we need a simple way to differentiate them:
*   **Must-Haves:** Sizes M and L drive the most sales. We absolutely need to keep these well-stocked.
*   **Good-to-Haves:** Size XL sells reasonably well. We should stock it, maybe not as deeply as M and L.
*   **Optional/Lower Priority:** Size S sells, but less than the others. Maybe we stock fewer units.

How do we capture this classification (Must-Have, Good-to-Have, Lower Priority) for *each size* within *each product group* in *each store*?

The **Pivotal Tag** concept provides these simple labels (P, NP, E), and the **`PivotalRow`** object stores this tag along with the context (size, product group, store).

## Core Concept: The P/NP/E Classification (Pivotal Tag)

The core idea is to assign a simple classification tag to every size within a specific context (product group + location). These tags tell us about the relative importance and expected demand for that size.

The tags are defined by the [`PivotalTag`](07_enumerations__enums__.md) enum:

1.  **`P` (Pivotal):** This tag marks a **core, high-demand size**. These are typically the best-selling sizes for that product group in that location. Think of them as the "must-haves". They usually make up the bulk of the sales volume (e.g., the sizes contributing to the top 70-80% of quantity sold, as determined by the ISS module).
    *   *Example:* Sizes M and L for our T-shirt in Store 101.
    *   *Implication:* Needs to be well-stocked, prioritized in buying and distribution.

2.  **`NP` (Non-Pivotal):** This tag marks a size with **moderate demand**. It sells, but not as much as the Pivotal sizes. Think of them as "good-to-haves". They contribute to sales but aren't the primary drivers.
    *   *Example:* Size XL for our T-shirt in Store 101.
    *   *Implication:* Should likely be stocked, but potentially with less depth than Pivotal sizes.

3.  **`E` (Exit):** This tag marks a **low-demand size**. These sizes contribute very little to sales within this context. They might be older sizes being phased out, niche sizes with minimal demand in this location, or simply the tail end of the size curve.
    *   *Example:* Size XXL for our T-shirt in Store 101 (which the ISS module might have excluded, or tagged as E if kept).
    *   *Implication:* Might not be stocked at all, or stocked minimally. Could be a candidate for clearance or removal from the assortment.

4.  **`UNTAGGED`:** This means the size wasn't successfully classified by the ISS process for this context, possibly due to lack of data or other issues.

These tags provide a concise, actionable summary of each size's importance.

## Core Concept: Storing the Tag (`PivotalRow`)

How do we store this P/NP/E tag so other parts of the system can use it? That's where the [`PivotalRow`](09_row_input_output_classes_.md) comes in.

A `PivotalRow` object is like a small record card that holds the assigned tag for one specific size in one specific product group at one specific location.

Its key fields are:

*   `store`: The ID of the store (or channel/location).
*   `ag`: The ID of the Attribute Group ([AgRow](16_agrow_.md)) representing the product group (e.g., "Men's V-Neck T-shirts").
*   `size`: The actual size string (e.g., "M", "L", "XL").
*   `sizeGroup`: The assigned [`PivotalTag`](07_enumerations__enums__.md) (P, NP, or E).
*   (Other fields like `contri`, `qtyPiv`, `flag` provide details about *how* the tag was derived by the ISS module).

So, for our T-shirt example in Store 101 (assuming it belongs to AG ID 500), we would have multiple `PivotalRow` records generated by the ISS module:

| store | ag  | size | sizeGroup | ... |
| :---- | :-: | :--- | :-------- | :-: |
| 101   | 500 | S    | NP        | ... |
| 101   | 500 | M    | P         | ... |
| 101   | 500 | L    | P         | ... |
| 101   | 500 | XL   | NP        | ... |
| 101   | 500 | XXL  | E         | ... |

This structured data clearly defines the importance of each size for that specific product group and store.

## How PivotalRow Data is Used

The `PivotalRow` data is a key output of the Ideal Size Set calculation and serves as crucial input for many downstream processes:

*   **Assortment Planning:** Deciding *which* sizes to include in the plan for a store. Often, 'E' sizes are excluded.
*   **Buying/Ordering:** Determining *how many* units of each size to buy. More units are typically bought for 'P' sizes than 'NP' sizes.
*   **Allocation/Distribution:** Deciding how to distribute inventory arriving at a warehouse to different stores. Stores are more likely to receive inventory for their 'P' and 'NP' sizes.
*   **Replenishment:** Setting rules for automatically sending more stock to stores. 'P' sizes might have higher target stock levels.

**Example: Conceptual Buying Logic**

Imagine a module deciding how many units of each size to buy for our V-Neck T-shirt (AG 500) for Store 101. It might use the `PivotalRow` data like this:

```java
// Simplified buying logic

import com.increff.irisx.row.output.iss.PivotalRow;
import com.increff.irisx.constants.ap.PivotalTag;
import java.util.Map; // Assume pivotalDataMap: Map<Key(store, ag, size), PivotalRow>

int storeId = 101;
int attributeGroupId = 500;
String[] sizesToConsider = {"S", "M", "L", "XL", "XXL"};
Map<String, Integer> buyQuantities = new HashMap<>();

for (String size : sizesToConsider) {
    // Create a key to look up the PivotalRow
    Key lookupKey = new Key(storeId, attributeGroupId, size);
    PivotalRow pRow = pivotalDataMap.get(lookupKey); // Get the tag info

    int quantityToBuy = 0;
    if (pRow != null) {
        // Decide quantity based on the tag
        if (PivotalTag.isP(pRow.sizeGroup)) { // Is it Pivotal?
            quantityToBuy = 50; // Buy more for P sizes
        } else if (PivotalTag.isNP(pRow.sizeGroup)) { // Is it Non-Pivotal?
            quantityToBuy = 20; // Buy less for NP sizes
        } else { // Must be Exit (E) or Untagged
            quantityToBuy = 0; // Buy zero for E sizes
        }
    } else {
        System.out.println("Warning: Pivotal data not found for size " + size);
        quantityToBuy = 0; // Default to zero if no data
    }
    buyQuantities.put(size, quantityToBuy);
}

System.out.println("Calculated Buy Quantities: " + buyQuantities);

```

**Explanation:**

1.  The code iterates through the potential sizes for the T-shirt.
2.  For each size, it looks up the corresponding `PivotalRow` data (which contains the P/NP/E tag) using a key composed of the store, attribute group, and size.
3.  It checks the `sizeGroup` tag using helper methods from the `PivotalTag` enum (e.g., `PivotalTag.isP()`).
4.  Based on the tag, it assigns a different `quantityToBuy`.

**Expected Output (based on our example tags):**

```
Calculated Buy Quantities: {S=20, M=50, L=50, XL=20, XXL=0}
```

This shows how the simple P/NP/E tag directly drives decisions about how much to invest in each specific size.

## Under the Hood: Origin and Structure

As we saw in the [Ideal Size Set (ISS) Module (ApIssGroupModule)](26_ideal_size_set__iss__module__apissgroupmodule__.md) chapter, the `PivotalRow` objects and their `sizeGroup` tags are generated during that process.

*   **Origin:** The `ISSTaggingModule` calculates size contributions and applies benchmarks (`SizeSetPropertiesRow`) to assign the initial P/NP/E tags. The `ISSSizeContinuityModule` then potentially adjusts these tags to ensure logical size runs. The `ISSOutputModule` finally consolidates and saves this information as `PivotalRow` objects.
*   **Data Structure (`PivotalRow.java`):** The class itself is a straightforward data holder.

```java
// File: src/main/java/com/increff/irisx/row/output/iss/PivotalRow.java
package com.increff.irisx.row.output.iss;

import com.increff.irisx.constants.ap.PivotalTag; // Import the Enum

// Holds the classification for a specific Size + AG + Store combination
public class PivotalRow {

    public int store;       // Store ID
    public int ag;          // Attribute Group ID
    public String size;     // The specific size (e.g., "M")

    public int sizeSeq;     // ID of the size sequence (e.g., "Mens_Tops")
    public PivotalTag sizeGroup; // <<--- The important P/NP/E tag

    public int flag;        // How the tag was derived (e.g., store vs channel level)

    // Metrics used/calculated during ISS:
    public double qty;       // Sales quantity for this size/ag/store
    public double qtyPiv;    // The % threshold used to determine Pivotal status
    public double contri;    // % contribution (before adjustments)
    public double adjContri; // % contribution (after adjustments/normalization)
    public double rawQty;      // Raw sales qty
    public double unbrokenQty; // Sales qty from "unbroken" periods

    // Constructor sets a default tag
    public PivotalRow(){
        this.sizeGroup = PivotalTag.EMPTY;
    }
}
```

*   **The Tag (`PivotalTag.java`):** The possible values for `sizeGroup` are defined in the Enum.

```java
// File: src/main/java/com/increff/irisx/constants/ap/PivotalTag.java
package com.increff.irisx.constants.ap;

import com.increff.irisx.constants.EnumInterface;
import com.increff.irisx.constants.LanguageUtil;

// Defines the possible classifications for a size's importance
public enum PivotalTag implements EnumInterface {

    P("P", "P"),               // Pivotal - High demand
    NP("NP", "NP"),            // Non-Pivotal - Moderate demand
    E("E", "E"),               // Exit - Low demand / Phase out
    UNTAGGED("UNTAGGED", "SIN_ETIQUETAR"), // Not classified
    EMPTY("", "");             // Default/Empty

    // --- Helper methods for easy checking ---
    public static boolean isPOrNP(PivotalTag tag) {
        return tag.equals(PivotalTag.P) || tag.equals(PivotalTag.NP);
    }
    public static boolean isP(PivotalTag tag) { return tag.equals(PivotalTag.P); }
    public static boolean isNP(PivotalTag tag) { return tag.equals(PivotalTag.NP); }
    public static boolean isExit(PivotalTag tag) { return tag.equals(PivotalTag.E); }
    // ... (Constructors, other methods as seen in Chapter 7) ...
}
```

## Conclusion

The **Pivotal Tag** (P/NP/E) and the **`PivotalRow`** data structure are fundamental outputs of the Ideal Size Set calculation in `irisx-algo`.

*   The **Tag** provides a simple classification (**Pivotal, Non-Pivotal, Exit**) indicating the relative sales importance of a size within a specific product group and location.
*   The **`PivotalRow`** object stores this tag along with its context (size, attribute group, store).
*   This classification is crucial for driving downstream decisions in **assortment planning, buying, allocation, and replenishment**, ensuring focus and resources are directed towards the most important sizes.

By translating complex sales data into these simple, actionable tags, the Pivotal Tag / PivotalRow concept plays a key role in optimizing inventory investment and assortment relevance.

Now that we have a good handle on the ideal *set* of sizes (ISS) and their relative importance (Pivotal Tag), how do we decide *how many* units of each Pivotal or Non-Pivotal size we should aim to keep in stock? This leads us to the concept of "depth". The next chapter introduces the [Optimum Depth (OD) Module (ApOdGroupModule)](28_optimum_depth__od__module__apodgroupmodule__.md).

[Next Chapter: Optimum Depth (OD) Module (ApOdGroupModule)](28_optimum_depth__od__module__apodgroupmodule__.md)

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)