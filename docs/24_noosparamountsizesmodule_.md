# Chapter 24: NoosParamountSizesModule

Welcome back! In the [previous chapter](23_noosbestsellercomputemodule_.md), we met the `NoosBestsellerComputeModule`, which helps us identify the current hot-selling items in our inventory. We now know how to label products as "Core" (the essentials) or "Bestseller" (the current stars). Collectively, we often refer to these as "NOOS" (Never Out Of Stock) items because, ideally, we want to keep them available.

But think about a popular style, like a classic pair of sneakers (let's say it's identified as a Core item). These sneakers come in many sizes, maybe from size 5 all the way up to size 15. Should we treat *all* these sizes as equally important NOOS items? Probably not!

## What Problem Does This Module Solve?

Imagine you run that shoe store. Your classic sneaker (a Core style) sells consistently. But you notice that sizes 8, 9, 10, and 11 make up almost 80% of all the sales for that sneaker style. The other sizes (5, 6, 7, 12, 13, 14, 15) sell occasionally, but not nearly as much.

If you treat *all* sizes as critical "Never Out Of Stock" items, you might end up ordering too many of the less popular sizes (like size 15) and tying up valuable money and shelf space. It's much smarter to focus your efforts on ensuring the *most important* sizes – the ones that drive most of the sales – are always available.

But how do you figure out which sizes are the "most important" for each Core or Bestseller style? Doing this manually for every product group (like Men's Sneakers from Brand X, or Women's T-shirts from Brand Y) would be very time-consuming.

The **`NoosParamountSizesModule`** solves this problem. It acts like a smart sales analyst that automatically identifies the **"paramount"** or **most important sizes** for NOOS items within specific product groups. It looks at sales data to find the smallest set of sizes that accounts for a large chunk (e.g., 80%) of the revenue for that group.

## Core Idea: Finding the 80/20 Sizes

The main idea is based on the Pareto principle (often called the 80/20 rule), which suggests that roughly 80% of the results often come from 20% of the causes. In our case, it means a small number of sizes likely contribute to the majority of the revenue for a particular product group.

`NoosParamountSizesModule` works like this:

1.  **Group Products:** It looks at products grouped by key characteristics (like Channel, Category, Subcategory, Brand, Brand Segment, Gender – the same level used for NOOS identification).
2.  **Analyze Sales by Size:** Within each group, it calculates the total revenue generated by each individual size (e.g., Size 8 made $5000, Size 9 made $6000, Size 10 made $5500, Size 7 made $1000...).
3.  **Rank Sizes:** It ranks the sizes based on their revenue contribution, from highest to lowest.
4.  **Select Top Contributors:** It starts picking sizes from the top of the ranked list, adding up their revenue contribution percentages, until it reaches a target threshold (e.g., 80%, defined by `topXRevContrib` in `NoosArgs`).
5.  **Define Paramount Set:** The sizes selected in step 4 are declared the "Paramount Sizes" for that specific product group.

So, for our sneaker example, it might find:
*   Size 9: 30% Revenue
*   Size 10: 25% Revenue
*   Size 8: 15% Revenue
*   Size 11: 12% Revenue
*   (Cumulative: 30 + 25 + 15 + 12 = 82%)

Since we've crossed the 80% threshold, the module would declare sizes {8, 9, 10, 11} as the Paramount Sizes for that sneaker group.

## How It Works (The Process)

This module runs as part of the sequence managed by [NOOS Identification (NoosGroupModule)](21_noos_identification__noosgroupmodule__.md), typically *before* the Core and Bestseller calculations, because knowing the important sizes can sometimes influence those calculations (e.g., focusing analysis on sales of paramount sizes).

**Inputs:**
*   **Sales Data:** A list of [ProductSalesRow](13_productsalesrow_.md) objects, providing sales details linked to SKU (for size) and Style (for grouping attributes). Usually accessed via the [Cache](05_cache_.md).
*   **Configuration:** `NoosArgs` ([Configuration & Arguments (Args Classes)](03_configuration___arguments__args_classes__.md)) containing the `topXRevContrib` percentage threshold (e.g., 80.0).

**Calculation Steps:**
1.  **Group Sales:** Group the `ProductSalesRow` list by the defined "paramount size level" (Channel, Category, Subcategory, Brand, Brand Segment, Gender). This creates a map where each key represents a group, and the value is the list of sales for that group.
2.  **Process Each Group:** For each group:
    a.  **Calculate Revenue per Size:** Within the group's sales list, calculate the total revenue for each distinct size (`sku.size`).
    b.  **Calculate Total Group Revenue:** Sum up the revenue across all sizes in the group.
    c.  **Calculate Size Contribution %:** For each size, calculate `(Size Revenue / Total Group Revenue) * 100`.
    d.  **Sort Sizes:** Create a map of `Size -> Revenue Contribution %` and sort it in descending order based on the percentage.
    e.  **Select Top Sizes:** Iterate through the sorted sizes, adding them to a "Paramount Set" and summing their contribution percentages until the cumulative percentage meets or exceeds the `topXRevContrib` threshold.
3.  **Store Results:** Store the results in a map (`paramountSizesMap`) where the key is the group identifier (Channel, Cat, etc.) and the value is the `Set<String>` of paramount sizes for that group. This map is often stored in a shared data object like `NoosData` or potentially persisted.
4.  **Persist Output (Optional):** The module might also save the results as `ParamountSizesRow` objects ([Row Input/Output Classes](09_row_input_output_classes__.md)) for external use or reporting.

**Outputs:**
*   An updated shared map (`NoosData.paramountSizesMap`) holding the set of paramount sizes for each product group key.
*   Optionally, persisted `ParamountSizesRow` data.

## Under the Hood: Grouping, Sorting, Selecting

Let's trace the core logic.

**1. Grouping Sales:**
   The first step uses streams or loops to group the list of `ProductSalesRow` objects. The key for grouping combines multiple attributes (channel, cat, subcat, brand, etc.) to define the peer group.

   ```java
    // Simplified logic from NoosParamountSizesModule.computeParamountSizes
    // Assume 'productSales' is List<ProductSalesRow> from Cache

    // Group sales by the combined key (Channel, Cat, Subcat, Brand, etc.)
    Map<Key, List<ProductSalesRow>> aggSalesMap = productSales.stream()
        .collect(Collectors.groupingBy(
            // Helper creates a Key object from row's attributes
            psRow -> psRow.createChannelCatSubcatBrandBrSegGenderKey()
        ));
   ```
   **Explanation:** This code uses Java Streams to group the `productSales` list. For each `ProductSalesRow`, it creates a composite `Key` based on its channel, category, brand, etc. The result `aggSalesMap` holds each group's sales list mapped by its key.

**2. Processing a Single Group (Calculating Contributions & Selecting Top):**
   The module then iterates through `aggSalesMap`. For each group:

   ```java
    // Simplified logic processing one group (key, salesProductRows)
    private void processGroup(Key key, List<ProductSalesRow> salesInGroup) {
        // Calculate total revenue for this specific group
        double totalRevenue = ProductSalesUtil.getTotalRevenue(salesInGroup);
        if (totalRevenue <= 0) return; // Skip groups with no revenue

        // Calculate revenue per size within this group
        Map<String, Double> revenuePerSize = salesInGroup.stream()
            .collect(Collectors.groupingBy(
                psRow -> psRow.sku.size, // Group by size string
                Collectors.summingDouble(psRow -> psRow.sale.revenue) // Sum revenue per size
            ));

        // Calculate revenue contribution % for each size and sort descending
        Map<String, Double> sortedContribMap = new LinkedHashMap<>();
        revenuePerSize.entrySet().stream()
            .map(entry -> {
                // Calculate % contribution
                double contrib = MathUtil.divide(entry.getValue() * 100, totalRevenue);
                return new AbstractMap.SimpleEntry<>(entry.getKey(), contrib);
            })
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed()) // Sort high to low
            .forEachOrdered(entry -> sortedContribMap.put(entry.getKey(), entry.getValue()));

        // Select top sizes based on contribution threshold
        Set<String> paramountSizes = new HashSet<>();
        double cumulativeContrib = 0.0;
        for (Map.Entry<String, Double> entry : sortedContribMap.entrySet()) {
            if (cumulativeContrib >= noosArgs.topXRevContrib) {
                break; // Stop once threshold is reached
            }
            paramountSizes.add(entry.getKey()); // Add the size
            cumulativeContrib += entry.getValue(); // Add its contribution
        }

        // Store the result for this group (Key -> Set<Size>)
        paramountSizesMap.put(key, paramountSizes);
    }
   ```
   **Explanation:**
   *   Calculates `totalRevenue` for the group using [ProductSalesUtil](14_productsalesutil_.md).
   *   Groups the sales within the group by `sku.size` and sums the revenue for each size.
   *   Calculates the contribution percentage for each size using [MathUtil](12_mathutil_.md).
   *   Sorts the sizes by their contribution percentage in descending order.
   *   Iterates through the sorted sizes, adding them to the `paramountSizes` set until the `cumulativeContrib` reaches the `topXRevContrib` threshold from `NoosArgs`.
   *   Stores the resulting set of paramount sizes in the `paramountSizesMap` using the group's key.

**Sequence Diagram (Processing One Group):**

```mermaid
sequenceDiagram
    participant NPSM as NoosParamountSizesModule
    participant SalesList as List<ProductSalesRow> (Group's Sales)
    participant PSU as ProductSalesUtil
    participant MU as MathUtil
    participant ResultMap as Map<Key, Set<String>>

    NPSM ->> PSU: getTotalRevenue(SalesList)
    PSU -->> NPSM: Return totalGroupRevenue
    NPSM ->> SalesList: Group by Size, Sum Revenue -> revenuePerSize Map
    loop For each Size in revenuePerSize Map
        NPSM ->> MU: divide(sizeRevenue * 100, totalGroupRevenue)
        MU -->> NPSM: Return contributionPercent
    end
    NPSM ->> NPSM: Sort Sizes by contributionPercent (desc)
    NPSM ->> NPSM: Initialize empty paramountSet, cumulativePercent = 0
    loop For each Size in sorted order
        NPSM ->> NPSM: Add Size to paramountSet
        NPSM ->> NPSM: cumulativePercent += contributionPercent
        alt cumulativePercent >= threshold
            break Loop
        end
    end
    NPSM ->> ResultMap: Put(groupKey, paramountSet)
```

**3. Outputting Results (`ParamountSizesRow`):**
   If the module persists the output, it converts the final `paramountSizesMap` into `ParamountSizesRow` objects.

   ```java
    // Simplified logic from NoosParamountSizesModule.writeOutput
    private void writeOutput() {
        ArrayList<ParamountSizesRow> output = new ArrayList<>();
        paramountSizesMap.forEach((levelKey, sizes) -> {
            // Create row and extract attributes from the composite Key
            ParamountSizesRow row = new ParamountSizesRow();
            row.channel = (String) levelKey.part(0);
            row.category = (String) levelKey.part(1);
            // ... extract subcat, brand, brandSegment, gender from key ...
            row.sizeSet = sizes; // Store the set of paramount sizes
            output.add(row);
        });
        // Persist the list of rows
        db().truncateInsert(ParamountSizesRow.class, output);
        db().persistTable(ParamountSizesRow.class);
    }
   ```
   **Explanation:** This iterates through the `paramountSizesMap`. For each entry (group key and its set of sizes), it creates a `ParamountSizesRow`, populates the attributes by extracting them from the composite `levelKey`, sets the `sizeSet`, and adds it to a list to be persisted.

## Conclusion

The **`NoosParamountSizesModule`** plays a key role in the NOOS identification process by figuring out the most important sizes for product groups.

*   It analyzes sales data to find the **subset of sizes** that contribute the most to revenue (e.g., top 80%) within specific groups (Channel/Category/Brand/etc.).
*   It achieves this by **grouping sales, calculating revenue per size, ranking sizes by contribution, and selecting the top contributors** until a configured threshold is met.
*   The identified **Paramount Sizes** set is stored (often in `NoosData`) and used by other modules (like Core/Bestseller computation, inventory checks, or reordering logic) to focus on the sizes that matter most.

By identifying these key sizes, the module helps optimize inventory and ensure availability for the sizes that have the biggest impact on the business for Core and Bestseller items.

After identifying Core, Bestseller, and Paramount Sizes, there's often a need for manual adjustments. What if the business knows a specific item *should* be a Bestseller, even if the data doesn't fully support it yet? The next chapter looks at the [NoosBsOverrideModule](25_noosbsoverridemodule_.md), which handles these manual overrides.

[Next Chapter: NoosBsOverrideModule](25_noosbsoverridemodule_.md)

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)